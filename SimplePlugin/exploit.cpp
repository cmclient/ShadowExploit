#include "../plugin_sdk/plugin_sdk.hpp"
#include "exploit.h"
#include "utils.h"
#include "permashow.hpp"

namespace exploit
{

	TreeTab* main_tab = nullptr;

	namespace exploit
	{
		TreeEntry* enabled = nullptr;
		TreeEntry* step_1 = nullptr;
		TreeEntry* step_2 = nullptr;
		TreeEntry* lvl_12_notification = nullptr;
	}

	int count_wardstones();

	void exploit_step_1();
	void exploit_step_2();

	void update_glow();
	void show_notification();

	// Event handler functions
	void on_update();
	void on_draw();

	// Other
	int pulseAlphaValue = 255;
	bool goDownAlpha = true;

	void load()
	{
		main_tab = menu->create_tab("shadowexploit", "ShadowExploit");
		{
			main_tab->add_separator("separator_1", "ShadowExploit v1.1.5");
			const auto exploit = main_tab->add_tab("exploit", "Exploit Settings");
			{
				exploit->add_separator("separator_1", "Exploit Settings");
				exploit::enabled = exploit->add_hotkey("enabled", "Exploit Status", TreeHotkeyMode::Toggle, 'H', true);

				const auto gold = exploit->add_tab("gold", "Gold Exploit");
				{
					gold->add_separator("separator_1", "Gold Exploit");
					exploit::step_1 = gold->add_hotkey("step_1", "Get 2 wardstones (Before lvl 13)", TreeHotkeyMode::Hold, '8', false);
					exploit::step_2 = gold->add_hotkey("step_2", "Spam selling (After lvl 13)", TreeHotkeyMode::Hold, '9', false);
					exploit::lvl_12_notification = gold->add_checkbox("lvl_12_notification", "Show notification on level 12", true);
					const auto tutorial = gold->add_separator("separator_2", "Hover for tutorial");
					tutorial->set_tooltip("Before level 13:\n -> Have 2200+ gold\n -> Have ur inventory in this layout:\n  * Slot 1 - Support Item\n  * Slot 2 - One Control Ward\n  * Slot 3 - One Health Potion\n  * Slots 4-6 - Any cheap item (Fearie Charm for example)\n -> Leave base after buying items above then go into\n -> Press step 1 (8 by default) to execute\n\nAfter level 13:\n -> Make sure that you have full inventory\n -> Make sure that u get 2 wardstones from first step\n -> Make sure that you have 1000 stacks on support item\n -> Hold step 2 (9 by default) to execute");
				}
			}

			exploit->set_assigned_active(exploit::enabled);
		}

		{
			Permashow::Instance.Init(main_tab);
			Permashow::Instance.AddElement("Exploit Status", exploit::enabled);
			Permashow::Instance.AddElement("Get 2 wardstones (Before lvl 13)", exploit::step_1);
			Permashow::Instance.AddElement("Spam selling (After lvl 13)", exploit::step_2);
		}

		event_handler<events::on_update>::add_callback(on_update);
		event_handler<events::on_draw>::add_callback(on_draw);

		utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: Loaded version 1.1.5. Have Fun! Made by: kuezese#0375");
		utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: Check menu for gold exploit tutorial.");
	}

	void unload()
	{
		menu->delete_tab(main_tab);

		Permashow::Instance.Destroy();

		event_handler<events::on_update>::remove_handler(on_update);
		event_handler<events::on_draw>::remove_handler(on_draw);
	}

	// Step One
	float stepOneStart = 0.f;
	bool duringStepOne = false;
	bool stepOneHold = false;

	// Step two
	bool didTwoWardstones = false;
	bool didSoldWardstones = false;
	float stepTwoStart = 0.f;

	void on_update()
	{
		if (myhero->is_dead())
			return;

		if (!exploit::enabled->get_bool())
			return;

		const float currentTime = gametime->get_time();
		const bool stepOnePressed = exploit::step_1->get_bool();
		const bool stepOneContinue = stepOneStart + 1.f > currentTime;

		if (stepOnePressed || stepOneContinue)
		{
			if (stepOnePressed && !stepOneHold && !stepOneContinue)
			{
				if (myhero->get_gold() < 2200)
				{
					utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: You need 2200 gold or more!");
					return;
				}

				if (myhero->get_level() >= 13)
				{
					utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: You need level 12 or lower!");
					return;
				}

				for (int i = 6; i <= 11; i++)
				{
					const auto item = myhero->get_item((spellslot)i);

					if (!item)
					{
						utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: You need full inventory!");
						return;
					}
				}
			}

			if (stepOnePressed && !stepOneHold && !stepOneContinue)
			{
				stepOneStart = currentTime;
				stepOneHold = true;
			}

			exploit_step_1();
			return;
		}
		else if (!stepOnePressed && stepOneHold)
		{
			stepOneHold = false;
		}

		exploit_step_2();
	}

	void on_draw()
	{
		if (exploit::lvl_12_notification->get_bool())
		{
			show_notification();
		}
	}

	int count_wardstones()
	{
		int wardstones = 0;

		for (int i = 6; i <= 11; i++)
		{
			const auto item = myhero->get_item((spellslot)i);

			if (item && ((ItemId)item->get_item_id() == ItemId::Watchful_Wardstone || (ItemId)item->get_item_id() == ItemId::Vigilant_Wardstone))
			{
				wardstones++;
			}
		}

		return wardstones;
	}

	void exploit_step_1()
	{
		const int wardstones = count_wardstones();

		if (wardstones >= 2)
		{
			stepOneStart = 0.f;
			didTwoWardstones = true;
			utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: Already have 2 wardstones!");
			return;
		}

		const auto ward = myhero->has_item(ItemId::Control_Ward);
		const auto potion = myhero->has_item(ItemId::Health_Potion);

		if (ward != spellslot::invalid && potion != spellslot::invalid)
		{
			myhero->buy_item(ItemId::Watchful_Wardstone);
			scheduler->delay_action(0.0133f - (ping->get_ping() / 1000.f), [] {
				const int wardstones = count_wardstones();

				if (wardstones >= 2)
				{
					stepOneStart = 0.f;
					didTwoWardstones = true;
					return;
				}

				myhero->sell_item(myhero->has_item(ItemId::Health_Potion));
				const auto temp = myhero->has_item(ItemId::Watchful_Wardstone);
				if (temp != spellslot::invalid)
				{
					myhero->sell_item(temp);
					myhero->undo_item();
				}
				didTwoWardstones = true;
				utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: Completed.");
			});
		}
	}

	void exploit_step_2()
	{
		const float current = gametime->get_time();
		const bool has_passed = (current - stepTwoStart >= 0.1f);

		if (!has_passed)
			return;

		stepTwoStart = current;

		const spellslot vigilant = myhero->has_item(ItemId::Vigilant_Wardstone);

		if (exploit::step_2->get_bool())
		{
			if (!didTwoWardstones)
			{
				const int wardstones = count_wardstones();

				if (wardstones >= 2)
				{
					didTwoWardstones = true;
				}
				else
				{
					utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: First do step one!");
					return;
				}
			}

			if (myhero->get_level() < 13)
			{
				utils::print_chat("<font color=\"#4273cf\">[ShadowExploit]</font><font color=\"#FFFFFF\">: You need level 13 or higher!");
				return;
			}

			if (vigilant != spellslot::invalid)
			{
				didSoldWardstones = true;
				myhero->sell_item(vigilant);

				scheduler->delay_action(0.2f, [] {
					myhero->sell_item(myhero->has_item(ItemId::Vigilant_Wardstone));
				});
				return;
			}
		}

		if (didSoldWardstones)
		{
			const spellslot watchful = myhero->has_item(ItemId::Watchful_Wardstone);

			if (vigilant != spellslot::invalid && watchful == spellslot::invalid)
			{
				myhero->undo_item();
			}
			else if (vigilant == spellslot::invalid && watchful == spellslot::invalid)
			{
				myhero->undo_item();
				myhero->undo_item();
			}
		}
	}

	void update_glow()
	{
		if (static_cast<int>(gametime->get_prec_time() * 1000.f) % 50 > 10)
			return;

		if (!goDownAlpha)
			pulseAlphaValue += 10;
		else
			pulseAlphaValue -= 10;

		if (pulseAlphaValue <= 0)
		{
			pulseAlphaValue = 0;
			goDownAlpha = false;
		}
		else if (pulseAlphaValue >= 255)
		{
			pulseAlphaValue = 255;
			goDownAlpha = true;
		}
	}

	void show_notification()
	{
		if (myhero->get_level() == 12 && count_wardstones() != 2)
		{
			update_glow();

			constexpr int fontSize{ 20 };
			constexpr int rectWidth{ 450 };

			const std::string	text{ "YOU ARE LEVEL 12 - BUY WARDSTONES" };
			const float			width{ static_cast<float>(renderer->screen_width()) / 2.f };
			const float			height{ static_cast<float>(renderer->screen_height()) - 200.f };
			const vector		widthOffset{ draw_manager->calc_text_size(fontSize, text.c_str()) / 2 }; // divide by 2 cause we want to center it.

			const vector textPos{ width, height };


			const vector position = textPos - vector{ rectWidth / 2, 30 };
			const vector box_size = vector{ rectWidth, 60 };

			draw_manager->add_filled_rect(position - vector{ 3, 3 }, position + box_size + vector{ 3, 3 }, MAKE_COLOR(221, 164, 39, pulseAlphaValue));
			draw_manager->add_filled_rect(position, position + box_size, MAKE_COLOR(14, 22, 23, 255));

			draw_manager->add_text_on_screen(textPos - widthOffset, MAKE_COLOR(255, 255, 255, 255), fontSize, text.c_str());
		}
	}
}